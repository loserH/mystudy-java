package com.study.javaclass.common;

import org.bouncycastle.math.ec.ECPoint;

import java.io.IOException;
import java.math.BigInteger;

public class SM2Utils {

    //数据解密
    public static byte[] decrypt(byte[] privateKey, byte[] encryptedData) throws IOException {
        if (privateKey == null || privateKey.length == 0) {
            return null;
        }

        if (encryptedData == null || encryptedData.length == 0) {
            return null;
        }
        //加密字节数组转换为十六进制的字符串 长度变为encryptedData.length * 2
        String data = Util.byteToHex(encryptedData);
        /** 分解加密字串
         * （C1 = C1标志位2位 + C1实体部分128位 = 130）
         * （C3 = C3实体部分64位  = 64）
         * （C2 = encryptedData.length * 2 - C1长度  - C2长度）
         */
        byte[] c1Bytes = Util.hexToByte(data.substring(0,130));
        int c2Len = encryptedData.length - 97;
        byte[] c2 = Util.hexToByte(data.substring(130,130 + 2 * c2Len));
        byte[] c3 = Util.hexToByte(data.substring(130 + 2 * c2Len,194 + 2 * c2Len));

        SM2 sm2 = SM2.Instance();
        BigInteger userD = new BigInteger(1, privateKey);

        //通过C1实体字节来生成ECPoint
        ECPoint c1 = sm2.ecc_curve.decodePoint(c1Bytes);
        Cipher cipher = new Cipher();
        cipher.Init_dec(userD, c1);
        cipher.Decrypt(c2);
        cipher.Dofinal(c3);

        //返回解密结果
        return c2;
    }

    public static void main(String[] args) throws IOException {
		//sm2私钥
		String privatekey="00E77AEA394D689ECC1F9D14E843F2B60ACFA31A06107C1BD775DC1309D93C5750";
        //加密串 说明：加密前是"测试解密"
		String encrypt = "042EB539005CFE50979433708F4899CA3105DF3480A33CB25E616841ECFB7984C998049516AF166B305DE79D85DA77E25B01561967C2958CCEDC41B9873C17EFA79ACC66C8E6F4E700950C58DC720675FECBF2EC0DF8D107D897F610361B072FA5E15AE36B65DFC11DDF99FB492D74D955E8833B05C0A845F0757F97B280AF6D6D309F6D2C53E2066516A014B4738668B815535160CD2C30C5DA8F156C85FDF46DAEBBDB8BFB55A7C029FFE5151C3DE99BD5E9019E080307727D9B5139959DCB51A514C364034248901A14FBC293489C2AB2D2563B53ADE2ABBB997E680D2FDB08DE5B344ADAFCCFD5E05B53A79F56DF4F64BF6641120BC543A196AED5E0660E1D93BFB90AD176B792AD26449E6838E8700A3C8DF0076663279A4FD0B1D06901C30E94A34D216FF7C2C2D3812B24AC6C80D2735DB4663C805A7271B8A4CB6207D09C9127384CE97C33462D0B2A62AB041369D50068D820536E039951CCD7D9E15975CEF9A7D7BD2CDD2BC0C646EF22224EE5D93A2E98C4B9CD85C32EBFDE9A5CE5AE43E7A98945853DA33D7D2E8C52F6127EA60D570361EA9286AD91C540ACBDC1A1C0F8C86D6FC88EC6252520424BE6930581B3961207E32D3C2BE4733F1AA48B97F3BF803F26ED553CF4286717C10A330623088B4B9E7DB746989AC2ADFF721C4FB7DC44E7EAA13A324652559AC74B5A8D8905F497FE655B99207B7F2BBC8FA4ABAB1E32413D380448CBB0AA116BB50DCE5F73A1BA106ED96A333FE1E2200EB30C11A3226BAFCD35DBE0071D46F65718A4CC6F3B927841257721B97604CE3073B301F1A5E73E90EB74866E0A5DD946E6FC22C863D3947DEFC9A4FE4A50C161CB71F395CDA48873EB4E9ABB4676C16DA3236B817074529B4B8B96DAEA8C113062FC0FC19F23B78A862A322E7103D5608EB3668E355E9D1A82B4BB6A2A0B2450FDC90CC4FD2AED9C7B3C40961599FA94C69703EEDA449EC7FF48B936DB185431BFCF07170CEB32CD1023FF0135F7D2F27EB877B20B5E684F73401A967720046B13B0744DBF0525DF809DDF34CFF1EE65427903A0DE379F851D8B83A29FAD992A8B4D7E0C1DF69E753C972B58DEA1FE476FC60D3618A70F28C6CA721C799BB3A0406A8D8CF7FDA80187E24733B15B9A75A3BF678D09BF9E95AE4D1E8EAB97EF4684758A627325";

        // 将加密后的信息解密，私钥和加密后的数据的字节码对象需要用util里的hexToByte方法
        byte[] decrypt = decrypt(Util.hexToByte(privatekey), Util.hexToByte(encrypt));
        // 将字节数组转为字符串
        String newInfo=new String(decrypt,"utf-8");
        System.out.println("解密后信息:"+newInfo);

    }
}